// On curing cervical cancer via early detection of type II biomorphic virality via anonymous jpeg image. 
// Intel's ML (or Deep learning as it's called with more than 2 layers of neural decision maps) SDK is one of the libraries one is encouraged to use, as a 20k prize goes to most inventive use of Intel technology

// BBLF-KFH73J56  -- INTEL SDK deep learning signature

// ssh key ea:69:5a:4a:66:c8:cf:c6:32:cf:a5:1c:33:14:66:a5 curingCancerForTheOutkasts
// everything'sEventual

// entropicOfCancer
// author: JC Aggeles

// thanks to Mrs. Kernighan, Richie, and everyone at Bell Labs (et al) who helped design and maintain B & C
// special thanks to Mrs. Gates and Allen and the Microsoft support team for their help with the VS Code integrated development environment and the windows family of operating systems
// a very special thanks to Alan Turing and Walter Pitts (et al, particularly McCullough) for their work on AI -- we love you all, forever and forever
#include<cstdlib>
#include<libc.lib>


//  NOTE: look at radiance library for illuminative implementations of structures for 3D imaging impressions
//  polygon in 3 d space and add squishing in shape to contour the polygon around and within the biomorphic tendencies 
//  of the human morphology


typedef struct struct poly

typedef struct struct rgb

typedef struct struct px

typedef struct struct q

typedef struct struct d

typedef struct struct rst // restart interval

typedef struct struct extract // polygons for each mapping style

typedef struct struct transformers // transformed polygons for each mapping style

typedef struct struct pli // snek

typedef struct struct nes // snek's friends


// on huffman decoding: 

// the table is to be read as follows:

// first byte (8 bits) is length of table
// second is set of values, corresponding to start bitstring of first value
// third is set of amounts, in order of ascending bit string length
// example: Let's let the first byte after the length byte be some ascii character that corresponds to some integer
// when divided by two, the corresponding index in the value set of bytes is a byte that corresponds to bitstring of, say, 1000. 
// Let's let the length ascii character's integer representation be a 4, then there are 4 bytes in the encoding schema, 1000, 1001, 1011, and 1101. 
// Each of these represents some ascii code that can then be translated into an RGB value set as done in the above function.  

struct nes()
{
	int * x;
	int * y;
	int * z;

	char * neighbor; // data at given coordinate

}; // nes


struct pli()
{

	int snekSz;
	char * snek;
	nes * friends;


}; // pli


struct act()
{
	int nPenrose;
	int nFuzzy;
	int nOverlap;

	poly * penrose;
	poly * fuzzy;
	poly * overlap;

}; // extracted ploygons


struct mir()
{
	int nPen;
	int nFuzz;
	int nOver;

	poly * tPenrose;
	poly * tFuzzy;
	poly * tOverlap;


}; // matrix modulated polygons


struct rgb()
{

//for each level of chromesence and luminosity, when that is possible, a transformation within some planar space is necessary 
//to learn any permutations that might be more readable vis a vis those relationships.

	int * row; // pointer to row for respective pixel data
	int * col; // column for same

	int * y // the luminosity
	int * aCr; // red shifted chromesence (cool word)
	int * aCb; // blue shifted ""

	int * dCr; // first pixel data for the image data 
	int * dCb; // second pixel data for the image data

	short * yP; // y coordinate on plane
				// for representing the numeric relationship relative in a more 'objective' 3-D perspective
	short * xP; // same for x and z
	short * zP; 

}; // rgb



// as the number of sides approaches 360, a circle is observed
struct poly()
{
		
	int sides; 

	int * radii; // various lengths of radii, primarily the horizontal and the vertical, though extra radii are also quite possible and may well prove very interesting! 
				// it would be very good to extend radii within extra planes beyond the one that the polygon currently inhabits, such that the polygon would extend within many 
				// different planes such that each length (much as a snek might describe) would or (more rightly, statistically speaking) _could_ extend into different planes. 
	
	double angle = 360/sides;
	// the angle of the polygonal bend 
	
	rgb * px; 
	// subsampled components
		
	int x; 
	int y;
	int z;
	// where the polygon's x,y,z coordinates are located within the master image, anchored from top left corner

	int n; 
	// nPixels in this polygon
	
	int * node[2]; 
	// where the polygon coordinates with respect to its nearest neighbor 

	double * lambda;

	// frequency of overlap if regularity is present 

	double * gradient;

	// delta of lambda

	double * variance;

	// delta of gradient

	double * multiplier;

	// shift in variance (given some max/min, the multiplier will add stochastic noise to the variance to give more "organic" data, and therefore more room to accommodate real world morphology)  

	int * t; 

	// x,y node transformed around some point in parallel planar space

	char ** mod; 
	
	// transformed (scaled) byte array
	
}; // polygonal struct 


// cross reference each of the trees using a K-nearest neighbor clustering strategy .


/////////////////// DECODE ENTROPIC DATA /////////////////////////////


struct d(char * vals, char * amts, int len)
{

//r is byte that denotes size of table

int len = (int)m[0];

char * com[len] = { 0 };
char * qua[len] = { 0 };

//char ** tropics; // create a separate function to encode b tree
rgb * tim = rgb(m, len, r, c);



while(l >= 0)
{
   u = strpbrk(tim->, unit); // if single exists in master array
    
    
    l--;
}


len = strcspn(m[o], m*); // get position within array


int a = this->z;
int b, e = 0;

size_t len;

const char * u = '';

int * t[7716] = { 0 }; // (UniCode-8)

int * rows[this->r] = { 0 };
int * columns[this->c] = { 0 };					   

int index = 0;

int o = this->z;

char * unit = malloc(this->z, 1); // every symbol from MRI/fMRI/photographm -- parsed and bucketed for weighting  

	for( b = this->r; b > 0; b--)
	{	
		for( e = this->c; e > 0; e--)
		{
			
			
			if(NULL != unit) {
				
				

				t[len]++; // byte bucket
				columns[b]++; // column bucket 
				rows[e]++; // row bucket 
					
			} // if
			else
			{
				unit[index++] = u; // else add it to the bucketed list
				
			} // else
			
			o--;

		} // for columns
		
	} // for rows
	
	if(o > 0) printf(%c, %d, "margin of error when decoding d: ", o);
	
} // Huffman data


////////////////////////// SCALE THE POLYGON TO QUANTIZE /////////////////////////////


struct q(short _q)
{
	
	int scale;
	
	if(q < 50 ) scale = (int)(5000 / q);
	else scale = 200 - 2*q;
	
}; // q


////////////////////// BEGIN CLASS DEFINITION ///////////////////////


class: pic
{

public:

virtual pic(char * _i, char * _o, char * rLen, char * cLen)
{

this->i = _i; 
this->o = _o;

init(); // BEGIN

byte(); // READ

decode(); //DECODE

quantize(); //QUANTIZE

penrose(); // TILE

fuzzy(); // QUASI-RANDOM TILING

overlap(); // TILING WITH REGULAR OVERLAP

transform(); // takes in a set of plygons and transforms relative to one another, in a crystalline format

map(); // map polygons to jpeg, and extract them from image.

lisp(); // write lisp compatible data structures   

prolog(); // write prolog knowledge base to file for logical comparison of byte driven text.

deep(); // organize for parallel and hyperthreaded computation

learn(); // derive monotonicity

export(); // massive simulation in Azure, gCloud, AWS, bMix in virtual machine

free(); // REMOVE DATA FROM MEMORY

};

virtual ~pic(){};

protected:

d * decode();
rgb * rgb();

extract * actors;

const char ** par; /// PARAMETERS FROM COM
const char ** byt; /// BYTES WITHIN JPEG

d * ds; //huffman tables

void byte(); // READ
bool write(); // WRITE

void decode(); //DECODE

void quantize(); //QUANTIZE

void penrose(); // TILE

void fuzzy(); // QUASI-RANDOM TILING

void overlap(); // TILING WITH REGULAR OVERLAP

void transform(); // takes in a set of plygons and transforms relative to one another, in a crystalline format

void map(); // map polygons to jpeg, and extract them from image.

void lisp(); // compare polygonal space using lisp wrapper  

void prolog(); // write prolog knowledge base to file for logical comparison of byte driven text.

void free(); // REMOVE DATA FROM MEMORY

void test();

const char * i;
const char * o;


int * n; // number of pixels in entire image
int * np; //number of polygons extracted from image, in increasing order of nSides

char * r; // n rows
char * c; // n columns

const char * start = '0xDA';

// SOS 	0xFF, 0xDA 	variable size 	
// Start Of Scan 

const char * eos = '0xD9';

// end of scan


const char * stuff = '0xFF';

// each pair begins with one of the two above

 
const char * sof0 = '0xC0'; 

// SOF0 0xFF, 0xC0 	variable size
// Start Of Frame (baseline DCT) 

	
// Indicates that this is a baseline DCT-based JPEG, 
// and specifies the width, height, number of components, and component subsampling 
// (e.g., 4:2:0)


const char * sof1 = '0xC2';

// SOF2 	0xFF, 0xC2 	variable size 	
// Start Of Frame (progressive DCT) 	


// Indicates that this is a progressive DCT-based JPEG
// and specifies the width, height, number of components, and component subsampling 
// (e.g., 4:2:0).


const char * dht = '0xC4';

// DHT 	0xFF, 0xC4 	variable size 	
// Define Huffman Table(s) 	

// Specifies one or more Huffman tables.


const char * dqt = '0xDB';

// DQT 	0xFF, 0xDB 	variable size 	
// Define qntization Table(s) 	

// Specifies one or more qntization tables.


const char * dri = '0xDD';

// DRI 	0xFF, 0xDD 	4 bytes 	
// Define Restart Interval 
	
// Specifies the interval between RSTn markers, in Minimum Coded Units (MCUs). 
// This marker is followed by two bytes indicating the fixed size so it can be
// treated like any other variable size segment.


const char * sos = '0xDA';
	
// Begins a top-to-bottom scan of the image. 
// In baseline DCT JPEG images, there is generally a single scan. 
// Progressive DCT JPEG images usually contain multiple scans. 
// This marker specifies which slice of data it will contain 
// and is immediately followed by entropy-coded data.

// start and stop for entropic data

const char * r0 = '0xD0';
const char * r1 = '0xD1';
const char * r2 = '0xD2';
const char * r3 = '0xD3';
const char * r4 = '0xD4';
const char * r5 = '0xD5';
const char * r6 = '0xD6';
const char * r7 = '0xD7';

// application specific byte codes 

const char * a0 = '0xE0';
const char * a1 = '0xE1';
const char * a2 = '0xE2';
const char * a3 = '0xE3';
const char * a4 = '0xE4';
const char * a5 = '0xE5';
const char * a6 = '0xE6';
const char * a7 = '0xE7';


const char * com = '0xFE';

float multiplier = rand();

}; // pic class definition 



///////////////// FUNCTION DEFINITION ///////////////////////////////


// TODO: verification of memory availability during allocation 

void pic::init(char * m, char * type)
{

this->i = m[0];
this->o = m[1];
this->n = (int)m[2];

poly * p = malloc(this-n, sizeof(poly));


///////////// Monte Carlo ///////////////


const char * penrose = 'p';
const char * overlap = 'o';
const char * fuzzy = 'f';


static int radialOffsetX;
static int radialOffsetY;
//static int radialOffsetZ;

static int side = rand() % ( (int)argc[6] - (int)argc[5] );
static int radius = rand() % ( (int)argc[4]  - (int)argc[3] );



if( (int)type == (int)penrose)
{
	radialOffsetX = 0;
	radialOffsetY = 0;
}

if( (int)type == (int)overlap){

	radialOffsetX = rand() % ((int)argc[8] - (int)argc[7]);
	radialOffsetY = rand() % ((int)argc[10]- (int)argc[9]);

}

					while (n-- > 0)
					{

                   		p[n].sides = malloc(1, sizeof(int) );
						p[n].radius = malloc(1, sizeof(int) );
						
						p[n].radialOffsetX = malloc(1, sizeof(int));
						p[n].radialOffsetY = malloc(1, sizeof(int));
						
						p[n].lambda = malloc(1, sizeof(int));
						
						p[n].t[0] = rand() % ((int)argc[8] - (int)argc[7]);
						p[n].t[1] = rand() % ((int)argc[10] - (int)argc[9]);
						p[n].t[2] = rand() % ((int)argc[12] - (int)argc[11]);
						
						if((int)type == (int)fuzzy)
						{
							radialOffsetX = rand() % ((int)argc[8] - (int)argc[7]);
							radialOffsetY = rand() % ((int)argc[10]- (int)argc[9]);
						}

						p[n].sides = sides;
						p[n].radius = radius; 
						
						p[n].lambdaX = 1/(radius - radialOffsetX);
						p[n].lambdaY = 1/(radius - radialOffsetY);
						
						p[n].radialOffsetX = radialOffsetX;
						p[n].radialOffsetX = radialOffsetY;		
					
					} // while
} // init 


///////////////////////////////// CONVERT BYTES TO RGB DATA //////////////////////////


rgb * px(char * m, char * length, int r, int c, int rowLen)
{

	rgb * t = malloc( length, sizeof(rgb) ); // length of byte set that has pixel data
	
	int i;

	for(i = 0; i < length; i++)
	{

		t[i]->col = malloc(1, sizeof(int));
		t[i]->row = malloc(1, sizeof(int));

		t[i]->y = malloc( 1, sizeof(int) );
		t[i]->Cr = malloc( 1, sizeof(int) );
		t[i]->Cb = malloc( 1, sizeof(int) );

		t[i]->xP = malloc(1, sizeof(short) );
		t[i]->yP = malloc(1, sizeof(short) );
		t[i]->zP = malloc(1, sizeof(short) );

		t[i]->row = r;
		t[i]->col = c;

		t[i]->y = ( (int)m[0] >> 16 ) & 0xFF ) / 255.0; //  luminesence
		t[i]->Cr = ( (int)m[0] >> 8 ) & 0xFF ) / 255.0;  //  red shift (chromesence)
    	t[i]->Cb = ( (int)m[0] & 0xFF ) / 255.0;       //  blue shift

		t[i].xP = 255 - y;
		t[i].yP = 255 - arc;
		t[i].zP = 255 - abc;

	// test values of y, cr, cb to see if within short range or if in int range

	} // for

	return t;

} // px



//////////////// decode entropic data using huffman's reductionist b-tree strategy /////////////////////////////////



d * de(int rowSize, char * du, int rStar, int cStar){

int n = (int)du[0];
int nCols, nRows;

if( ( rowSize > rStar ) && (rowSize < n) ) nCols = rowSize;
else 
{
	nCols = rowSize - rStar;
}

nRows = (int)( (rowSize-rStar)/n );

int half = n/2;

char * vals = malloc(half, 1);
char * amts = malloc(half, 1);

int i; 

for(i = 0; i < n; i++)
{
	if(n < half) vals[i] = du[i];
	else {
		amts[i] = du[i];
	}


}

px * r = malloc( nRows*nCols, sizeof(px) );
int x;

int r = rStar;
int c = cStar;
int t = 0;

	for(x = 0; x < (nRows*nCols); x++)
	{
		t = 0;

		if( ( r == 0 ) && ( t < 2 ) ) 
		{
			px[x] = malloc(du[x].amount, sizeof(px));
			px[x] = px(r, c++, du[x].value, du[x].amount); 
			t++;

		} // if 
		
		else if( ( r%x == 1) && (c == 0) && ( t < 2) )
		{  
			px[x] = malloc( du[x].amount, sizeof(px) );
			px[x] = px( r++, c, du[x].value, du[x].amount ); 
			t++;

		}//else if
		
		else if( r%2 == 0 ) && ( t <= r ) 
		{
			px[x] = malloc(du[x].amount, sizeof(px));
			px[x] = px(r--, c++, du[x].value, du[x].amount);
			t++;

		}// else if

		else if(() c%2 == 1) && ( t <= c))
		{ 
			px[x] = malloc(du[x].amount, sizeof(px));
			px[x] = px(r++, c--, du[x].value, du[x].amount); 
			t++;

		}// else if

	} // for entropic table

} // decode


/////////////// FILE READ/WRITE //////////////////////////////////


bool pic::byte(){
	
	FILE * f = fopen( this->i, 'r' );
	
	fseek( f, 0L, SEEK_END );

	this->z = static_cast<int>( ftell(f) );

	this->byt = malloc( this->z, 1 );

	int e;

		for(e = 0; e < this->z; e++)
		{

			fread( this->byt[e], 1, 1, f );

		} // for 
	
	fclose( f );

write( this->byt );



} // byte 

//////////////////// get patterns ////////////////////////

void extractPolygons(){

	this->actors[0] = penrose( this->p, this->byt );
 	this->actors[1] = overlap( this->p );
	this->actors[2] = fuzzy( this->p );

 	this->mirrors[0] = transform( actors[0] );
	this->mirrors[1] = transform( actors[1] );
 	this->mirrors[2] = transform( actors[2] );

} // extract polygons



////////////////// write it ////////////////////////////


bool pic::write(char * byt)
{

int e;

	for( e = 0; e < this->z; e++ )
	
	{

		if(strcmp(byt[e], this->start) == 0) printf( %c, "st\n" );

		if(strcmp(byt[e], this->stuff) == 0) printf( %c, "sf\n" );

		if(strcmp(byt[e], this->sof0) == 0) printf( %c, "s1\n" );
		if(strcmp(byt[e], this->sof1) == 0) printf( %c, "s1\n" );

		if(strcmp(byt[e], this->dht) == 0) printf( %c, "dh\n" );
		if(strcmp(byt[e], this->dqt) == 0) printf( %c, "dq\n" );

		if(strcmp(byt[e], this->dri) == 0) printf( %c, "dr\n" );

		if(strcmp(byt[e], this->sos) == 0) printf( %c, "so\n" );

		if(strcmp(byt[e], this->r0) == 0) printf( %c, "r0\n" );
		if(strcmp(byt[e], this->r1) == 0) printf( %c, "r1\n" );
		if(strcmp(byt[e], this->r2) == 0) printf( %c, "r2\n" );
		if(strcmp(byt[e], this->r3) == 0) printf( %c, "r3\n" );
		if(strcmp(byt[e], this->r4) == 0) printf( %c, "r4\n" );
		if(strcmp(byt[e], this->r5) == 0) printf( %c, "r5\n" );
		if(strcmp(byt[e], this->r6) == 0) printf( %c, "r6\n" );
		if(strcmp(byt[e], this->r7) == 0) printf( %c, "r7\n" );

		if(strcmp(byt[e], this->a0) == 0) printf( %c, "a0\n" );
		if(strcmp(byt[e], this->a1) == 0) printf( %c, "a1\n" );
		if(strcmp(byt[e], this->a2) == 0) printf( %c, "a2\n" );
		if(strcmp(byt[e], this->a3) == 0) printf( %c, "a3\n" );
		if(strcmp(byt[e], this->a4) == 0) printf( %c, "a4\n" );
		if(strcmp(byt[e], this->a5) == 0) printf( %c, "a5\n" );
		if(strcmp(byt[e], this->a6) == 0) printf( %c, "a6\n" );
		if(strcmp(byt[e], this->a7) == 0) printf( %c, "a7\n" );

		else printf( %c, %c, byt[e], "," ); 

	} // for 

} // write 


// to->prolog knowledge base 

bool pic::writeLogos(char * byt)
{

int e;

	for( e = 0; e < this->z; e++ )
	
	{

		if(strcmp(byt[e], this->start) == 0) printf( %c, "st\n" );

		if(strcmp(byt[e], this->stuff) == 0) printf( %c, "sf\n" );

		if(strcmp(byt[e], this->sof0) == 0) printf( %c, "s1\n" );
		if(strcmp(byt[e], this->sof1) == 0) printf( %c, "s1\n" );

		if(strcmp(byt[e], this->dht) == 0) printf( %c, "dh\n" );
		if(strcmp(byt[e], this->dqt) == 0) printf( %c, "dq\n" );

		if(strcmp(byt[e], this->dri) == 0) printf( %c, "dr\n" );

		if(strcmp(byt[e], this->sos) == 0) printf( %c, "so\n" );

		if(strcmp(byt[e], this->r0) == 0) printf( %c, "r0\n" );
		if(strcmp(byt[e], this->r1) == 0) printf( %c, "r1\n" );
		if(strcmp(byt[e], this->r2) == 0) printf( %c, "r2\n" );
		if(strcmp(byt[e], this->r3) == 0) printf( %c, "r3\n" );
		if(strcmp(byt[e], this->r4) == 0) printf( %c, "r4\n" );
		if(strcmp(byt[e], this->r5) == 0) printf( %c, "r5\n" );
		if(strcmp(byt[e], this->r6) == 0) printf( %c, "r6\n" );
		if(strcmp(byt[e], this->r7) == 0) printf( %c, "r7\n" );

		if(strcmp(byt[e], this->a0) == 0) printf( %c, "a0\n" );
		if(strcmp(byt[e], this->a1) == 0) printf( %c, "a1\n" );
		if(strcmp(byt[e], this->a2) == 0) printf( %c, "a2\n" );
		if(strcmp(byt[e], this->a3) == 0) printf( %c, "a3\n" );
		if(strcmp(byt[e], this->a4) == 0) printf( %c, "a4\n" );
		if(strcmp(byt[e], this->a5) == 0) printf( %c, "a5\n" );
		if(strcmp(byt[e], this->a6) == 0) printf( %c, "a6\n" );
		if(strcmp(byt[e], this->a7) == 0) printf( %c, "a7\n" );

		else printf( %c, %c, byt[e], "," ); 

	} // for 

} // write 


////////////// POLYGONAL EXTRACTION /////////////////////////////////


void pic::map()
{

byt(this->i);

FILE * o = fopen(this->o, 'r');

int e, q, next = 0;
int u = 0;
bool du = 1;

for(r = 0; r < n; r++)
{
	for(e = 0; e < this->z; e++)
	{
		
	switch(byt[e++]){
		
		case this->start:

			if( (int)byt[e] == (int)this->stuff ) e++; // jump padding
	
				switch(byt[e++])
				{
		
//////////////////// start of sof0 /////////////////////////////

				case this->sof0:  
					
					init( this->&p[r], 0 );
				   
					next = (int)byt[e];
					
					if( next == (int)this->dri ) 
					{	
						size = (int)byt[e];
						this->p[r].px = malloc( size, sizeof(rgb) );
					
						while( (int)byt[e] != (int)this->eos )  
						{
							if( (int)byt[e] != (int)this->com ) 
							{	
								p[r].px[e] = rgb( &byt, &e, 0 ); 	
							} // if
							
							e++;
							size--;
							
						} // while
						
						if(size != 0) printf( %c, %i, "margin of error: ", size ); 

						else printf(%c,  "no image data present");
										
					next = (int)byt[e];
					
					if(next == (int)this->q) q( &p[r], &byt, &e++ ); // pass pointers to keep e in order
					
						next = (int)byt[e++];       
					
					if(next == (int)this->d) d( &byt[e] );  

						next = (int)byt[e++]; // again, pass params by reference to maintain e's ordering

/////////////////// start of sof1 ////////////////////////////

				case this->sof1: 
					init( this->&p[r], 1 );
								
					if( next == (int)this->dri ) 
					{	
						size = (int)byt[ e ];
						p[ r ].px = malloc( size, sizeof( rgb ) );
					
						while( (int)byt[e] != (int)this->eos )  
						{
							if( (int)byt[e] != (int)this->com ) {
								
								p[r].px[e] = rgb(&byt, &e, 1); 								
							} // if
							
							e++;
							size--;
							
						} // while
						
						if(size != 0) printf( %c, %i, "margin of error: ", size ); 

					} // if	

					else printf( %c, "no image data present" );
										
					next = (int)byt[ e ];
					
					if(next == (int)this->q) q( &p[r], &byt[ e++ ] ); 
					
					next = (int)byt[ e ];
					
					if(next == (int)this->d) d( &p[r], &byt, &e );
					next = (int)byt [ e++ ];
				
			
					
			} // switch 
			
		} // for 
	
	return fclose(this->w);	
		
} // map


/////////////////// ENCODING & DECODING /////////////////////////////////


d * ma(char * h)
{
	int len = (int)h[0];
	d * o = malloc( s, sizeof(d) );
	d.value = malloc( s, sizeof(int) );
	d.freq = malloc( s, sizeof(int) );

	int i;
	int s = len/2;

	char values = malloc(s, 1);
	char number = malloc(s, 1);

	for(i = 0; i < len, i++)
	{
		if(i < s) d.value[i] = h[i];
		else d.freq[i] = h[i];
	
	} // for

return o;

} // ma


////////////////////// MAPPING STRATEGIES //////////////////////////////

// regular (though not perfectly married) polygon tiling, with a nod to Dr. Roger Penrose

void pic::penrose(int * side, int * radius, int * n)
{ 
	
	poly * p = malloc( n, sizeof(poly) );
	
	int d, u = 0;
	
	int x = 1;

	for(d = 1; d <= (this->r - radius); d++)
	{
		for(u = 1; u <= (this->c - radius); u++)
		{	 
			if( (d == (side * x)) && (c == ( radius*2*x ) ))
			{
				init(&p[x], &side, &radius);
					
					p[x].x = u;
					p[x].y = d;
					
					x++;
					
				} // if 
				
			} // c 
		
		} // r 
	
	map( &p, 'p' );
	
} // penrose 

// wavelet overlay of each polygon to look for repetitive patterns that emerge from the viral tendency to 
// migrate only as far as it can remain attached to the initial culture -- similar to human expansion near sources of water

void pic::overlap(char ** m){
	
	int polys = ( this->z/(radius * 2) );
	
	poly * p = malloc( polys, sizeof(poly) );
	
	int d, u;
	
	int x = 1;

	for( d = 1; d <= this->r; d++ )
	{
			for( u = 1; u <= this->c; u++ )
			{	 
				if( d == ( ( side - lenBuffer) * x ) && ( u == ( (radius*2*x) - radialBuffer ) )
				{
					init( &p[x], &side, &radius );	
					
					p[ x ].x = u;
					p[ x ].y = d;
					
					x++;
				} // if 
				
			} // for col 
		
	} // for row
	
	map( &p, 'o' );
	
} // overlap 

/
// useful to consider hyperspacial analysis purposes
 
void pic::fuzzy(int * side, int * radius, int *  n)
{	
	
	poly * p = malloc( n, sizeof(poly) );
	
	int row;
	int column;

	if(NULL != p)  // add more memory, son!
	
	for( i = 0; i < n; i++ )
	{

		for( row = 0; row < this->r; row++ )
		{

			for( column = 0; column < this->c; column++ )
			{	

				radius = rand() % (xRadius - nRadius);

				init(&p, &side, &radius )

				p[ i ].y = row;
		
				p[ i ].x = column;

				p[ i ].angle = ( this->multiplier )* 360/side;

			}

		}

	} // for 
		
	map( &p, 'f' );
		
} // fuzzy 


////////////////// TRANSFORMATIONS /////////////////////////////


void pic::qnt(poly * p, char ** m)
{
	q q( (int)m );
	scalePoly( &p, &q, &m );
	
} // qnt


void scalePoly( poly * p, q * q, char ** m )
{
	int i = 0;
	char ** newByt = malloc( p->n, 1 );
	 
	while( i < p->n )
	{
		newByt.px[ i ] = ( m[i] * q->scale + 50 )/100; 	
		i++;
		
	} // while

		p.mod = newByt; 
	
} // scalePoly


int main(int argv, char ** argc)
{

	pic * p(argc[1], argc[2]);
	p->test();

/*	int diff = (argv - 12);
	if(diff != 0) printf(%d, %c, diff ," parameters")
	else{

		pic * p(argc);

	} // else 	
*/	

} // main